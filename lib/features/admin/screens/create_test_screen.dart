import 'dart:math';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';

class CreateTestScreen extends StatefulWidget {
  final String examId;
  final String weekId;

  const CreateTestScreen({super.key, required this.examId, required this.weekId});

  @override
  State<CreateTestScreen> createState() => _CreateTestScreenState();
}

class _CreateTestScreenState extends State<CreateTestScreen> {
  // --- Basic Info ---
  final _testTitleController = TextEditingController();
  DateTime? _unlockTime;
  int _durationMinutes = 60;

  // --- Marking Scheme ---
  double _positiveMark = 4.0;
  double _negativeMark = 1.0;
  double _skipMark = 0.0;

  // --- Questions Data ---
  List<Map<String, dynamic>> _questions = [];
  bool _isGenerating = false; // To show loader while fetching

  // 1Ô∏è‚É£ Pick Date & Time
  void _pickDate() async {
    DateTime? picked = await showDatePicker(
      context: context,
      initialDate: DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2030),
    );
    if (picked != null) {
      TimeOfDay? time = await showTimePicker(context: context, initialTime: TimeOfDay.now());
      if (time != null) {
        setState(() {
          _unlockTime = DateTime(picked.year, picked.month, picked.day, time.hour, time.minute);
        });
      }
    }
  }

  // 2Ô∏è‚É£ Manually Add/Edit Question Dialog
  void _showManualQuestionDialog({Map<String, dynamic>? existingQ, int? index}) {
    final qController = TextEditingController(text: existingQ?['question'] ?? '');
    final optA = TextEditingController(text: existingQ?['options']?[0] ?? '');
    final optB = TextEditingController(text: existingQ?['options']?[1] ?? '');
    final optC = TextEditingController(text: existingQ?['options']?[2] ?? '');
    final optD = TextEditingController(text: existingQ?['options']?[3] ?? '');
    int correctIndex = existingQ?['correctIndex'] ?? 0;

    showDialog(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            title: Text(existingQ == null ? "Add Manually" : "Edit Question"),
            content: SingleChildScrollView(
              child: Column(
                children: [
                  TextField(controller: qController, decoration: const InputDecoration(labelText: "Question Text"), maxLines: 2),
                  const SizedBox(height: 10),
                  TextField(controller: optA, decoration: const InputDecoration(labelText: "Option A")),
                  TextField(controller: optB, decoration: const InputDecoration(labelText: "Option B")),
                  TextField(controller: optC, decoration: const InputDecoration(labelText: "Option C")),
                  TextField(controller: optD, decoration: const InputDecoration(labelText: "Option D")),
                  const SizedBox(height: 10),
                  DropdownButton<int>(
                    value: correctIndex,
                    isExpanded: true,
                    items: const [
                      DropdownMenuItem(value: 0, child: Text("Correct: Option A")),
                      DropdownMenuItem(value: 1, child: Text("Correct: Option B")),
                      DropdownMenuItem(value: 2, child: Text("Correct: Option C")),
                      DropdownMenuItem(value: 3, child: Text("Correct: Option D")),
                    ],
                    onChanged: (v) => setDialogState(() => correctIndex = v!),
                  )
                ],
              ),
            ),
            actions: [
              TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("Cancel")),
              ElevatedButton(
                onPressed: () {
                  if (qController.text.isNotEmpty) {
                    Map<String, dynamic> newQ = {
                      'question': qController.text,
                      'options': [optA.text, optB.text, optC.text, optD.text],
                      'correctIndex': correctIndex,
                    };
                    setState(() {
                      if (index != null) {
                        _questions[index] = newQ;
                      } else {
                        _questions.add(newQ);
                      }
                    });
                    Navigator.pop(ctx);
                  }
                },
                child: const Text("Save"),
              )
            ],
          );
        },
      ),
    );
  }

  // ---------------------------------------------------------
  // üî• NEW: AUTO GENERATE DIALOG (From Database)
  // ---------------------------------------------------------
  void _showAutoGenerateDialog() {
    String? selectedSubjectId;
    String? selectedTopicId;
    int questionCount = 5;

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setSheetState) {
            return Padding(
              padding: EdgeInsets.fromLTRB(20, 20, 20, MediaQuery.of(context).viewInsets.bottom + 20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text("ü§ñ Auto-Fetch Questions", style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
                  const SizedBox(height: 15),

                  // 1. SELECT SUBJECT
                  const Text("Select Subject:", style: TextStyle(fontWeight: FontWeight.bold)),
                  StreamBuilder<QuerySnapshot>(
                    stream: FirebaseFirestore.instance.collection('subjects').snapshots(),
                    builder: (context, snapshot) {
                      if (!snapshot.hasData) return const LinearProgressIndicator();
                      var subjects = snapshot.data!.docs;
                      return DropdownButton<String>(
                        value: selectedSubjectId,
                        isExpanded: true,
                        hint: const Text("Choose Subject"),
                        items: subjects.map((s) {
                          var data = s.data() as Map<String, dynamic>;
                          return DropdownMenuItem(value: s.id, child: Text(data['subjectName'] ?? 'Subject'));
                        }).toList(),
                        onChanged: (val) => setSheetState(() {
                          selectedSubjectId = val;
                          selectedTopicId = null; // Reset topic
                        }),
                      );
                    },
                  ),

                  const SizedBox(height: 15),

                  // 2. SELECT TOPIC (Dependent on Subject)
                  if (selectedSubjectId != null) ...[
                    const Text("Select Topic:", style: TextStyle(fontWeight: FontWeight.bold)),
                    StreamBuilder<QuerySnapshot>(
                      stream: FirebaseFirestore.instance
                          .collection('topics')
                          .where('subjectId', isEqualTo: selectedSubjectId)
                          .snapshots(),
                      builder: (context, snapshot) {
                        if (!snapshot.hasData) return const LinearProgressIndicator();
                        var topics = snapshot.data!.docs;
                        if (topics.isEmpty) return const Text("No topics found.");
                        
                        return DropdownButton<String>(
                          value: selectedTopicId,
                          isExpanded: true,
                          hint: const Text("Choose Topic"),
                          items: topics.map((t) {
                            var data = t.data() as Map<String, dynamic>;
                            return DropdownMenuItem(value: t.id, child: Text(data['topicName'] ?? 'Topic'));
                          }).toList(),
                          onChanged: (val) => setSheetState(() => selectedTopicId = val),
                        );
                      },
                    ),
                  ],

                  const SizedBox(height: 15),

                  // 3. NUMBER OF QUESTIONS
                  Row(
                    children: [
                      const Text("Quantity: ", style: TextStyle(fontWeight: FontWeight.bold)),
                      IconButton(onPressed: () => setSheetState(() { if(questionCount > 1) questionCount--; }), icon: const Icon(Icons.remove_circle)),
                      Text("$questionCount", style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                      IconButton(onPressed: () => setSheetState(() => questionCount++), icon: const Icon(Icons.add_circle)),
                    ],
                  ),

                  const SizedBox(height: 20),

                  // 4. FETCH BUTTON
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: (selectedTopicId != null) 
                        ? () {
                            Navigator.pop(ctx); // Close sheet
                            _fetchRandomQuestionsFromDB(selectedTopicId!, questionCount); // üî• Start Fetching
                          } 
                        : null,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple, foregroundColor: Colors.white),
                      icon: const Icon(Icons.download),
                      label: const Text("FETCH QUESTIONS"),
                    ),
                  )
                ],
              ),
            );
          },
        );
      },
    );
  }

  // üî• CORE LOGIC: Fetch Random Questions (Modified from your code)
  Future<void> _fetchRandomQuestionsFromDB(String topicId, int count) async {
    setState(() => _isGenerating = true);
    
    List<Map<String, dynamic>> newQuestions = [];
    List<Future<void>> tasks = [];

    // Loop 'count' times
    for (int i = 0; i < count; i++) {
      tasks.add(Future(() async {
        // 1. Random ID Generate
        String randomId = FirebaseFirestore.instance.collection('questions').doc().id;

        // 2. Query >= Random ID
        var query = await FirebaseFirestore.instance
            .collection('questions')
            .where('topicId', isEqualTo: topicId)
            .orderBy(FieldPath.documentId)
            .startAt([randomId])
            .limit(1)
            .get();

        if (query.docs.isNotEmpty) {
           _processFetchedDoc(query.docs.first, newQuestions);
        } else {
          // Wrap around logic (Start se utha lo agar end me kuch nahi mila)
          var startQuery = await FirebaseFirestore.instance
              .collection('questions')
              .where('topicId', isEqualTo: topicId)
              .orderBy(FieldPath.documentId)
              .limit(1)
              .get();
          
          if (startQuery.docs.isNotEmpty) {
             _processFetchedDoc(startQuery.docs.first, newQuestions);
          }
        }
      }));
    }

    await Future.wait(tasks);

    setState(() {
      _questions.addAll(newQuestions);
      _isGenerating = false;
    });

    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Added ${newQuestions.length} Questions!")));
  }

  // Helper to convert Firestore Doc to our Map format
  void _processFetchedDoc(QueryDocumentSnapshot doc, List<Map<String, dynamic>> list) {
    var data = doc.data() as Map<String, dynamic>;
    
    // Check duplication
    bool exists = _questions.any((q) => q['question'] == data['question']); // Check existing list
    bool existsInNew = list.any((q) => q['question'] == data['question']);  // Check current batch

    if (!exists && !existsInNew) {
      list.add({
        'question': data['question'] ?? 'No Question',
        'options': List<String>.from(data['options'] ?? []),
        'correctIndex': data['correctOptionIndex'] ?? 0, // Ensure key matches your DB (correctIndex vs correctOptionIndex)
        'id': doc.id // Store ID for reference
      });
    }
  }

  // 4Ô∏è‚É£ SAVE TEST
  void _saveTest() async {
    if (_testTitleController.text.isEmpty || _unlockTime == null || _questions.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Missing Title, Time or Questions!")));
      return;
    }

    try {
      await FirebaseFirestore.instance
          .collection('study_schedules')
          .doc(widget.examId)
          .collection('weeks')
          .doc(widget.weekId)
          .collection('tests')
          .add({
        'testTitle': _testTitleController.text.trim(),
        'unlockTime': Timestamp.fromDate(_unlockTime!),
        'questions': _questions,
        'createdAt': FieldValue.serverTimestamp(),
        'attemptedUsers': [],
        'settings': {
          'positive': _positiveMark,
          'negative': _negativeMark,
          'skip': _skipMark,
          'duration': _durationMinutes,
        }
      });
      if(mounted) Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error: $e")));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Create Test üìù")),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Title & Time
            TextField(controller: _testTitleController, decoration: const InputDecoration(labelText: "Test Title", border: OutlineInputBorder())),
            const SizedBox(height: 10),
            ListTile(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8), side: BorderSide(color: Colors.grey.shade300)),
              title: Text(_unlockTime == null ? "Select Start Date & Time" : "Starts: ${DateFormat('dd MMM - hh:mm a').format(_unlockTime!)}"),
              trailing: const Icon(Icons.calendar_today, color: Colors.deepPurple),
              onTap: _pickDate,
            ),
            
            const SizedBox(height: 20),
            
            // Questions Header with Buttons
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Questions (${_questions.length})", style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Row(
                  children: [
                    // Manual Add
                    IconButton(
                      onPressed: () => _showManualQuestionDialog(),
                      icon: const Icon(Icons.add_circle_outline, color: Colors.green),
                      tooltip: "Add Manually",
                    ),
                    // Auto Fetch (New)
                    ElevatedButton.icon(
                      onPressed: _isGenerating ? null : _showAutoGenerateDialog,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple.shade50, foregroundColor: Colors.deepPurple, elevation: 0),
                      icon: _isGenerating 
                        ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2)) 
                        : const Icon(Icons.auto_awesome, size: 18),
                      label: const Text("Auto"),
                    )
                  ],
                )
              ],
            ),
            const Divider(),

            // Question List
            _questions.isEmpty 
            ? const Padding(padding: EdgeInsets.all(20), child: Center(child: Text("No questions added yet.")))
            : ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: _questions.length,
              itemBuilder: (ctx, i) {
                var q = _questions[i];
                return Card(
                  margin: const EdgeInsets.only(bottom: 10),
                  child: ListTile(
                    title: Text("Q${i+1}: ${q['question']}", maxLines: 2, overflow: TextOverflow.ellipsis),
                    subtitle: Text("Ans: ${q['options'].length > q['correctIndex'] ? q['options'][q['correctIndex']] : 'Error'}"),
                    trailing: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(icon: const Icon(Icons.edit, size: 20, color: Colors.blue), onPressed: () => _showManualQuestionDialog(existingQ: q, index: i)),
                        IconButton(icon: const Icon(Icons.delete, size: 20, color: Colors.red), onPressed: () => setState(() => _questions.removeAt(i))),
                      ],
                    ),
                  ),
                );
              },
            ),

            const SizedBox(height: 30),
            
            // Save Button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _isGenerating ? null : _saveTest,
                style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple, foregroundColor: Colors.white, padding: const EdgeInsets.all(16)),
                child: const Text("SAVE FULL TEST", style: TextStyle(fontWeight: FontWeight.bold)),
              ),
            )
          ],
        ),
      ),
    );
  }
}
